\section{Evaluation}\label{Se:Evaluation}
%We mainly tested our tool on the GNU core utilities, differencing versions 6.10 and 6.11. This benchmark included 40 patches where most of the patches (35) were a one-line patch aimed at updating the version information string in the code. Our analysis easily showed equivalence for these programs. About 10 of these patches included actual changes to numerical variables and we were able to precisely describe the difference. We also tested our tool on a few handpicked patches taken from the Linux kernel and the Mozilla Firefox web browser.

%We implemented a union compiler named \emph{ucc} which creates union programs from any two C programs as well as a differencing oriented dataflow analysis solver for analyzing union programs, both tools use the LLVM and CLang compiler infrastructure. We analyze C code directly thus benefiting from a low number of variables as there are no temporary values as there might appear in an intermediate representation. We also benefit from our delta being computed over original variables. As mentioned in \secref{Union}, we normalize the input programs before unifying them for a simpler analysis.

%Analysis of some of our benchmarks required the use of widening. We applied a basic widening strategy which widens all cfg blocks once reaching a certain threshold. All of our experiments were conducted running on a Intel(R) Core-i7(TM) processor with 4GB.

\subsection{Results}

%\input{results-tab}

%\tabref{Results} summarizes the results of our analysis. The columns indicate the benchmark name and description, lines of code for the analyzed program, the number of lines added and removed by the patch, the number of diff-points generated, the numerical domain used, and the number of differences found in the analysis (i.e. number of diff-points where $\triangle \neq \varnothing$). In our benchmarks, we focused on computing intra-procedural difference between the two versions of procedures. Procedure calls presented difficulty as they potentially change global variables and local variables through pointers. We overcame this by either (i) assuming equivalence (alone) once we encounter a call to a procedure we already established as equivalent or (ii) warn that all results regarding variables touched by the procedure is un-sound. \TODO{In the majority of our benchmarks we identified calls only to library and system procedures thus we could omit their effect as they do not change variables beyond those given as parameter or those being assigned the return value.} All differences reported describe, in constraints over variables, an existing delta at that program point.

\paragraph{Capturing complex delta}
\figref{PrExample} depicts a patch made to \scode{char\_to\_clump} function in version 6.11. The patch replacing the execution of the line \scode{input\_position += width;}, which originally executed unconditionally, with a conditional structure that in the new version, allows the line to execute only under certain complex conditions. Since the variables handled in this patch (the global \scode{input\_position} and return value \scode{chars}) convey output, describing how their values changed and under which terms is important, especially as the patch cannot be easily parsed by a programmer to understand its meaning. Our analysis produces the following description for the differencing point at the return point:
\begin{lstlisting}
<-------------------
State with diff (return value, chars, input_position):
chars' = 0;
input_position = width;
input_position < 0;
input_position' = 0;
------------------->
<-------------------
State with diff (input_position):
input_position' = 0;
input_position < width;
width < 0;
------------------->
<-------------------
State with diff (input_position):
input_position' = 0;
input_position > width;
input_position <= 0; }
------------------->
\end{lstlisting}
The result convey the difference in the output variable values alongside some of conditions under which the difference occurs. The result is composed of three sub-states featuring difference (the offending variables appear before each sub-state) and adhere to two added paths in the patched program. The first sub-state belongs to the first branch in the added conditional: the difference is comprised of (i) the new value of \scode{input\_position} is 0 as opposed to it being \scode{width} in the former version (the analysis took the \scode{input\_position += width;} line into account and incorporated knowing that $input_position = 0$ from the branch condition). The analysis also deduced that the old \scode{input\_position} is negative under the same input as the branch condition dictates that \scode{width} is negative. (ii) \scode{chars} in the new program is 0 under this path. The two other sub-states adhere to the second added path in the conditional and track a difference for \scode{input\_position} alone, basically stating that \scode{input\_position} under this path used to assume values in ranges $[-\inf,width]$ and $[width,0]$ but now is simply 0. The splitting of this path into two cases is a result of expressing the non-convex $input_position \neq 0$ condition from the first branch conditional using two sub-states. Running the analysis again while saving the initial values of variables and parameters will produce an even more precise result as following:
\begin{lstlisting}
<-------------------
State with diff (return value, chars, input_position):
input_position_0 = 0;
chars' = 0;
input_position = width;
input_position < 0;
input_position' = 0;
------------------->
<-------------------
State with diff (input_position):
input_position_0 < -width;
input_position_0 < 0;
input_position' = 0;
input_position < width;
width < 0;
------------------->
<-------------------
State with diff (input_position):
input_position_0 < -width;
input_position_0 > 0;
input_position' = 0;
input_position > width;
input_position <= 0;
------------------->
\end{lstlisting}

\begin{figure*}
\centering
\begin{tabular}{cc}
\begin{lstlisting}
int input_position
bool char_to_clump(char c) {
  int width;
    ...
  input_position += width;
    ...
  return chars;
}
(*@ \vspace{0.6in} @*)
\end{lstlisting}
\hspace{1.0in}
&
\begin{lstlisting}
int input_position
bool char_to_clump'(char c) {
  int width;
    ...
  if (width < 0 && input_position == 0) {
      chars = 0;
      input_position = 0;
  } else if (width < 0 && input_position <= -width) {
    input_position = 0;
  } else {
    input_position += width;
  }
    ...
  return chars;
}
\end{lstlisting}
\\
coreutils pr.c v6.10 & coreutils pr.c v6.11
\end{tabular}
\caption{Original and patched version of coreutils \scode{pr.c}'s \scode{char\_to\_clump} procedure}
\figlabel{PrExample}
\end{figure*}

\paragraph{Identifying delta down the line}
One advantage of our analysis method is the ability to identify differences in variables that were not directly affected by the patch. \figref{Md5sumExample} shows part of the \scode{bsd\_split\_3} function that was patched by the line marked by a comment. Note that although the patch directly restricts the value range of \scode{s\_len} to above zero, our analysis is able to identify the effects on the index variable \scode{i} and also report a lost program state of \scode{i>-1} further down the line...

\begin{figure}[ht]\figlabel{Md5sumExample}
\lstset{numbers=left, language=C, basicstyle=\ttfamily\scriptsize,emph={},emphstyle=\textbf,escapechar=\%}
\centering
\begin{lstlisting}
static bool
bsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name) {
  size_t i;

  if (s_len == 0) return false; // Patch

  *file_name = s;

  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape
     filenames, so search backwards for the last ')'. */

  i = s_len - 1;
  while (i && s[i] != ')')
    i--;

  if (s[i] != ')') return false;

  s[i++] = '\0';

  while (ISWHITE (s[i])) i++;

  if (s[i] != '=') return false;
  i++;

  while (ISWHITE (s[i])) i++;

  *hex_digest = (unsigned char *) &s[i];
  return true;
}
\end{lstlisting}
\caption{md5sum.c bsd\_split\_3 function patch}
\end{figure}

\paragraph{Non-convex delta}

\paragraph{Maintaining equivalence in loops}

