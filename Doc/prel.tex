\section{Preliminaries} \seclabel{Preliminaries}
We use the following standard concrete semantics definitions for a program:

%\para{Program Location / Label} \deflabel{ProgramLabel}
A program location $loc \in Loc$, also referred to as label denoted $lab$, is a unique identifier for a certain location in a program corresponding to the value of the program counter at a certain point in the execution of the program. We also define two special labels for the start and exit locations of the program as $begin$ and $fin$ respectively.

%\para{Concrete State} \deflabel{ConcreteState}
Given a set of variables $Var$, a set of possible values for these variables $Val$ and the set of locations $Loc$, a \emph{concrete program state} is a tuple $\sigma \triangleq \langle loc, values \rangle \in \Sigma$ mapping the set of program variables to their concrete value at a certain program location $loc$ i.e. $values : Var \rightarrow Val$. The set of all possible states of a program $P$ is denoted $\Sigma_{P}$.

\begin{sloppypar}
%\para{Program} \deflabel{Program}
We describe an imperative program $P$, as a tuple $(Val,Var,\rightarrow,\Sigma_{0})$ where $\rightarrow : \Sigma_{P} \times \Sigma_{P} $  is a transition system which given a concrete program state returns the following state in the program and $\Sigma_{0}$ is a set of initial states of the program. Our formal semantics need not deal with errors states therefore we ignore crash states of the programs, as well as inter-procedural programs since our work deals with function calls by either ignoring them and only assuming equivalence for the output (if their input was indeed equivalent) when equivalence was proven or by inlining them (we exclude recursion for now).
\end{sloppypar}

%\para{Concrete Trace} \deflabel{ConcreteTrace}
A program trace $\pi \in \Sigma^*_{P}$, is a sequence of states $\langle \sigma_0,\sigma_1,... \rangle$ describing a single execution of the program.Every program can be described by the set of all possible traces for its run $\semp{P} \subseteq \Sigma^*$. We refer to these semantics as concrete state semantics. We also define the following standard operations on traces:
\begin{itemize}
\item $label : \Sigma_{P} \rightarrow Lab$ returns the program label of a state.
\item $last : \Sigma_{P}^* \rightarrow \Sigma_{P}$ returns the last state in a trace.
\item $pre : \semp{P} \rightarrow 2^{\Sigma_{P}^*}$ returns the set of all prefixes of a trace.
\item $states : \semp{P} \rightarrow 2^{\Sigma_{P}}$ returns the set of states the trace is composed of.
\end{itemize}


As we are addressing the semantics of two programs, we define the \emph{product state} $\sigma_{\times} \in \Sigma_{P \times P'}$ as a pair of states $\langle \sigma,\sigma' \rangle$, the \emph{product program} $P \times P'$ as a product of the transition systems of the underlying programs and \emph{product trace} as a sequence of product states.

