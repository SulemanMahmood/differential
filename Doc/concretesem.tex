\section{Concrete Semantics Delta}\seclabel{ConcreteSem}
In this section we will define the notion of difference between concrete semantics of two programs based on a standard concrete semantics for a program.

\subsection{Concrete State Differencing} \sublabel{ConcreteDiff}
Comparing two different programs $P$ and $P'$ under our concrete semantics means comparing \emph{traces}. A trace is composed of concrete states thus we first need a way to compare states. Since a state $\sigma$ is a mapping $Var \rightarrow Val$ we first need a correspondence between variables in $P$ (i.e. $Var$) and those in $P'$ (i.e. $Var'$).

\paragraph{Variable Correspondence} \deflabel{VarCorrespondence}
A variable correspondence $VC \in Var \times Var'$, is a partial mapping between 2 sets of program variables. Any variable in $Var$ may be matched with any in $Var'$ and vice versa. Naturally, the comparison between states will occur between values mapped to corresponding variables, as described by $VC$.

In our analysis, the correspondence can be determined by the user but our experience suggests that in most cases the set of variables stays the same ($Var = Var'$) over subsequent versions and in cases where $Var$ does change, it's by the addition of new variables or removal of an old one. Therefore we concluded that for our purposes, matching variables by name is sufficient for finding a precise difference. Thus we define our standard correlation to be: $VC_{EQ} \triangleq \{(v,v') | v \in Var \wedge v' \in Var' \wedge name(v) = name(v')\}$ and vice versa. %In cases where the matching is not that straightforward, for example, when variables name change, the correspondence can be generated in \TODO{a more sophisticated way}.

%% We give a much more verbose, directional definition for state delta

\paragraph{Concrete State Delta} \deflabel{ConcreteStateDelta}
Given two concrete states $\sigma \in \Sigma_P,\sigma' \in \Sigma_{P'}$ and a variable correspondence $VC$, we define the concrete state delta $\triangle_S(\sigma,\sigma')$ as the part of the state $\sigma$ where corresponding variables do not agree on values (with respect to $\sigma'$). Formally: $\triangle_{S}(\sigma,\sigma') \triangleq \{ (var,val) | (var,var') \in VC \wedge \sigma(var) = val \neq \sigma'(var')\}$. In case there is no observable difference in state we get that $\triangle_{S}(\sigma,\sigma') = \emptyset$. As state delta is directional, we notice that unless it is empty, $\triangle_{S}$ is not symmetric and we use the notation $\triangle_{S}^{-}$ for $\triangle_{S}(\sigma,\sigma')$ and $\triangle_{S}^{+}$ for $\triangle_{S}(\sigma',\sigma)$.

%In fact, the direction in which it is used has meaning in the context of a program $P$ and a patched version of it $P$. We define $\triangle_{S}^{-} = \triangle_{S}(\sigma,\sigma')$ which means the part of the state that was "changed" or "removed" in $P'$ and $\triangle_{S}^{+} = \triangle_{S}(\sigma',\sigma)$ which stands for the part added in $P'$.

For instance, given two states $\sigma:\{x=1,y=2,z=3\}$ and $\sigma':\{x'=0,y'=2,w'=4\}$ and assuming our default $VC$ then $\triangle_{S}^{-} = \{x=1\}$ since x and x' match and do not agree on value, y and y' agree (thus are not in delta) and z' is not in $VC_{EQ}$. Respectively, $\triangle_{S}^{+} = \{x'=0\}$. %We believe that $\triangle_{S}$ is a precise and natural definition for difference as it indeed captures the change made in the patched version. We will later on extend the definition to describe difference between abstract states.

We defined a notion for difference between states but this is insufficient to describe difference between whole runs of programs i.e. traces. Naturally, we are only interested in traces that originate from \textbf{the same input} \COMMENT{(for the input variables correlated by $VC$) although one can contemplate the question of delta between \emph{any} two traces of a program (or two programs) however this is not the problem addressed in this paper} and every mention of trace differentiation will assume the traces agree on input. The way to differentiate traces is by differentiating their states, but which states? this is not a trivial question since traces can vary in length and order of states. We need a state correspondence for choosing the states to be differentiated within the two traces. We define it as following:

\paragraph{Trace Diff Points} \deflabel{TraceDiffPoints}
Given two traces $\pi$ and $\pi'$, we define a trace index correspondence relation named trace diff points denoted $DP_{\pi}$ as a matching of indexes specifying states in where concrete state delta should be computed. Formally: $DP_{\Pi} \equiv \{(i,i')|i \in {0..|\pi|}, i' \in {0..|\pi'|}\}$. The question of supplying this matching, in a way that results in meaningful delta, is not a trivial one, we delay this discussion until we define the trace delta.

Now that we have a way of matching states to be compared between two traces, we define the notion of trace differentiation:

\paragraph{Trace Delta} \deflabel{ConcreteTraceDelta}
Given traces $\pi,\pi'$ of programs $P,P'$ respectively, and a state correspondence $DP_{\Pi}$ we define the trace delta $\triangle_{T}(\pi,\pi')$ as state differentiations between all corresponding states in $\pi$ and $\pi'$. Formally, for every $(i,i') \in DP$ such that $\triangle_{S}(\sigma_{i},\sigma'_{i'}) \neq \emptyset$, $\triangle_{T}$ will contain the mapping $i \mapsto \triangle_{S}(\sigma_{i},\sigma'_{i'})$, thus the result will map certain states in $\pi$ to their state delta with the corresponding state' in $\pi'$ (deemed interesting by $DP_{\Pi}$). We define $\triangle_{T}^{+}$ and $\triangle_{T}^{-}$ in a similar way.

One possible choice for $DP_{\Pi}$ would be the endpoints of the two traces $\{(fin,fin')\}$ (assuming they are finite) meaning differentiating the final states of the executions or formally: $\triangle_{in}^{-} \equiv \triangle_{Fin}(\pi,\pi') = \{fin\mapsto\triangle_{S}(\sigma_{fin},\sigma'_{fin'})\}$ (we will also be interested in $\triangle_{Fin}^{+}$). It is clear that the delta is not sufficient for truly describing the difference between said traces as it will only compare final state values and will miss out on what happened during the execution. This can be overcome by instrumenting the semantics such that the state will contain all "temporary" values for a variable along with the trace index (program location is not sufficient here as a trace can loop over a certain location) where the values existed by, for instance, adding temporary variables, allowing for a complete differentiation at the end point. This may substantially complicate the selection of $VC$ it will require a matching between all of these temporary, indexed, variables that will somehow produce meaning. Also the number of variables here can range up to the length of the trace.

Defining the $DP$ over any two traces is a daunting task since traces of separate (although similar) programs can vastly differ. If we take a look at two versions of a program depicted in \figref{MatcingProblemExamplePrograms} and the following traces generated from the input $x=2$: $\pi = \{x=2,i=0 \}\{i=1 \}\{i=2 \}$ and $\pi' = \{ x'=2,i'=0 \}\{ i'=1 \}\{ i'=2 \}\{ i'=3 \}\{i'=4\}$ (we omit labels and only mention parts of the trace where variable values change), we see that even in this simple program, finding a correlation based on traces alone is hard. However, one can get the sense that using program location as a means of correlation, one can produce a meaningful result. For example, if we look at all the possible values for $i$ in label $lab$ and differentiate them (as a set) from the values in the patched version (in the same location), we may get a meaningful result that $i$ in the patched version can range from $x+1$ up to $2x$. We will discuss differentiation os sets of states later on as we describe the collecting semantics.

\begin{figure}
\lstset{numbers=left, language=C, basicstyle=\ttfamily\scriptsize,emph={},emphstyle=\textbf,escapechar=\%}
\begin{tabular}{cc}
\centering
\begin{lstlisting}
void foo(unsigned x) {
    unsigned i = 0;
lab:if (i >= x) return;
    i++;
    goto lab;
}
\end{lstlisting}
&
\begin{lstlisting}
void foo(unsigned x) {
    unsigned i = 0;
lab:if (i >= 2*x) return;
    i++;
    goto lab;
}
\end{lstlisting}
\end{tabular}
\figlabel{MatcingProblemExamplePrograms}
\caption{$P,P'$ differentiation candidates}
\end{figure}

\subsection{Differencing at Program Labels} \sublabel{DiffAtLabels}

\paragraph{Trace Delta using Program Label}
Given two traces $\pi,\pi'$ and two program labels $l,l'$ we define a trace delta based on all traces locations (states) that are labeled $l,l'$. First we define $\pi_{l}$ as a sub-sequence of $\pi$ where only states that are labeled $l$ were chosen ($\pi'_{l'}$ is defined similarly). Next, we denote $\triangle_L(\pi_{l},\pi'_{l'})$ as a means for comparing these sequences. As $\pi_{l},\pi'_{l'}$ may vary in length and order, we cannot simply define it as applying $\triangle_{S}$ on each pair of states in $(\pi_{l},\pi'_{l'})$ by order. In fact, $\triangle_{L}$ can be defined in different way to reflect different concepts of difference, for instance, it can be defined as the differentiating the last states of $\pi_{l}$ and $\pi'_{l'}$ (assuming they are both finite) to reflect we are only interested in the final values in that location. We chose to define $\triangle_{L}$ as the difference between \emph{the set of states} which appear in $\pi_{l}$ against the set of those in $\pi'_{l'}$. Formally: $\triangle_{L_{set}}(\pi_{l},\pi'_{l'}) \triangleq \{ \sigma \in ran(\pi_{l}) | \neg \exists \sigma' \in ran(\pi'_{l'}) s.t. \triangle_{S}(\sigma,\sigma') = \emptyset \}$. For example, if we look at \figref{MatcingProblemExamplePrograms}, for $\pi, \pi'$ that originate from $x=2$  then $\triangle_{L_{set}}(\pi_{lab},\pi'_{lab'}) = \{\}$ and $\triangle_{L_{set}}(\pi'_{lab'},\pi_{lab}) = \{\{ i'=3 \},\{i'=4\}\}$. We see that this notion of $\triangle$ indeed captures a useful description of difference.

The problem of choosing $DP$ is now reduced to the matching of labels as the trace indexing correspondence $DP_{\Pi}$ defined in \defref{TraceDiffPoints} is no longer needed here. as we need to differentiate sets of states belonging to a certain program label. We require a correspondence of \emph{labels} and therefore we define the label diff points correspondence.

\paragraph{Label Diff Points} \deflabel{LabelDiffPoints}
Given two programs $P,P'$ and their sets of program labels $Lab,Lab'$, we define a label correspondence relation named label diff points denoted $DP_{Lab}$ as a matching of labels between programs. Formally: $DP_{Lab} \equiv \{(l,l')|l \in Lab, l' \in Lab'\}$. From this point on any mention of the diff-points correspondence $DP$ will refer to label diff-points $DP_{Lab}$. We address the question of selection of $DP_{Lab}$ in a meaningful way in \subref{DiffPoints}. %We will briefly mention that in order to find a meaningful correspondence, we employ a standard syntactic diff algorithm~\cite{Diff} on the two versions of the program. Our experiments show that for the purpose of differentiating versions of program, this approach works well since patched versions tend to be syntactically similar (especially when the versions come from two successive check-ins to the code repository).

Now, we will move past the concrete semantics towards a \emph{collecting semantics} as a step towards abstraction. This is required as it is unfeasible to describe difference based on traces. However, we need to adjust our concrete semantics before we can correctly define this as the collecting semantics based on individual traces \textbf{will not allow us to correlate traces that originate from the same input}. This is the first formal indication of how a separate abstraction, that considers each of the programs by itself, cannot succeed.

\paragraph{Collecting Semantics of a Program Label} \deflabel{ProgramLabelCollectingSemantics}
Given a label $l \in Lab$ in a program $P$ we define the collecting semantics of a program label $states(l) \subseteq \semp{P}$ as all the concrete states that are possible at that label (i.e. exist in some trace reaching that label). Formally:
\begin{enumerate}
\item $at \equiv Lab \rightarrow (\Pi \rightarrow 2^{\semp{P}^*})$ for a given label $l$ and trace $\pi$, is the set of prefixes of $\pi$ that end in a state labeled $l$ formally: $at(l,\pi) \equiv \{\pi*|\pi* \in pre(\pi) \wedge last(\pi*)=l \}$.
\item $states(l) \equiv \{last(at(l,\pi)) | \pi \in \Pi\}$.
\end{enumerate}

\paragraph{Collecting Semantics Delta} \deflabel{CollectingSemanticsDelta}
 We will use the correspondence of labels in $P$ and $P'$ ($DP$), to compute the collecting semantics delta. The delta will be computed individually for each pair of matched labels by using $states(l)$ and $states(l')$. This is somewhat similar to the label-based trace delta as now we handle \emph{sets} of states (instead of a series). We define collecting semantics delta by simply applying the state delta \defref{ConcreteStateDelta} between each of the states in both states and removing from the result matched states or formally: $\triangle_{C}(states(l) ,states(l')) \equiv \{\sigma \in states(l)| \neg \exists \sigma' \in states(l') \cdot \triangle_{S}(\sigma, \sigma') = \emptyset\}$

For example, given two sets of states $C : \{\sigma_1:\{x=0,y=0\},\sigma_2:\{x=1,y=2\}\}$ and $C' : \{\sigma'_1:\{x=0,y=0\},\sigma'_2:\{x=4,y=5\}\}$ and using $VC_Eq$ then $\triangle_{C}^{-} = \{\{x=1,y=2\}$ and $\triangle_{C}^{+} = \{\{x=4,y=5\}\}$. Note that $\triangle_{C}^{+}$ now obtains the meaning of "lost states" as in states which existed in the previous version and removed by the patch (similarly $\triangle_{C}^{-}$ here means "new states").

We must remember however, that the sets of states to be compared are potentially unbounded which means that the delta we compute may be unbounded too. Therefore we must use an abstraction over the collecting semantics that will allow us to represent the collecting semantics in a bounded way.
