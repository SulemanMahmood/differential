\section{Concrete Semantics Delta}\seclabel{ConcreteSem}
In this section we will define the notion of difference between concrete semantics of two programs based on a standard concrete semantics for a program.

\subsection{Concrete State Differencing} \sublabel{ConcreteDiff}
Comparing two different programs $P$ and $P'$ under our concrete semantics means comparing \emph{traces}. A trace is composed of concrete states thus we first need a way to compare states. Since a state $\sigma$ is a mapping $Var \rightarrow Val$ we first need a correspondence between variables in $P$ (i.e. $Var$) and those in $P'$ (i.e. $Var'$).

\paragraph{Variable Correspondence} \deflabel{VarCorrespondence}
A variable correspondence $VC \in Var \times Var'$, is a partial mapping between 2 sets of program variables. Any variable in $Var$ may be matched with any in $Var'$ and vice versa. Naturally, the comparison between states will occur between values mapped to corresponding variables, as described by $VC$.

In our analysis, the correspondence can be determined by the user but our experience suggests that in most cases the set of variables stays the same ($Var = Var'$) over subsequent versions and in cases where $Var$ does change, it's by the addition of new variables or removal of an old one. Therefore we concluded that for our purposes, matching variables by name is sufficient for finding a precise difference. Thus we define our standard correlation to be: $VC_{EQ} \triangleq \{(v,v') | v \in Var \wedge v' \in Var' \wedge name(v) = name(v')\}$ and vice versa. %In cases where the matching is not that straightforward, for example, when variables name change, the correspondence can be generated in \TODO{a more sophisticated way}.

%% We give a much more verbose, directional definition for state delta

\paragraph{Concrete State Delta} \deflabel{ConcreteStateDelta}
Given two concrete states $\sigma \in \Sigma_P,\sigma' \in \Sigma_{P'}$ and a variable correspondence $VC$, we define the concrete state delta $\triangle_S(\sigma,\sigma')$ as the part of the state $\sigma$ where corresponding variables do not agree on values (with respect to $\sigma'$). Formally: $\triangle_{S}(\sigma,\sigma') \triangleq \{ (var,val) | (var,var') \in VC \wedge \sigma(var) = val \neq \sigma'(var')\}$. In case there is no observable difference in state we get that $\triangle_{S}(\sigma,\sigma') = \emptyset$. As state delta is directional, we notice that unless it is empty, $\triangle_{S}$ is not symmetric and we use the notation $\triangle_{S}^{-}$ for $\triangle_{S}(\sigma,\sigma')$ and $\triangle_{S}^{+}$ for $\triangle_{S}(\sigma',\sigma)$.

%In fact, the direction in which it is used has meaning in the context of a program $P$ and a patched version of it $P$. We define $\triangle_{S}^{-} = \triangle_{S}(\sigma,\sigma')$ which means the part of the state that was "changed" or "removed" in $P'$ and $\triangle_{S}^{+} = \triangle_{S}(\sigma',\sigma)$ which stands for the part added in $P'$.

For instance, given two states $\sigma:\{x=1,y=2,z=3\}$ and $\sigma':\{x'=0,y'=2,w'=4\}$ and assuming our default $VC$ then $\triangle_{S}^{-} = \{x=1\}$ since x and x' match and do not agree on value, y and y' agree (thus are not in delta) and z' is not in $VC_{EQ}$. Respectively, $\triangle_{S}^{+} = \{x'=0\}$. %We believe that $\triangle_{S}$ is a precise and natural definition for difference as it indeed captures the change made in the patched version. We will later on extend the definition to describe difference between abstract states.

We defined a notion for difference between states but this is insufficient to describe difference between whole runs of programs i.e. traces. Naturally, we are only interested in traces that originate from \textbf{the same input} \COMMENT{(for the input variables correlated by $VC$) although one can contemplate the question of delta between \emph{any} two traces of a program (or two programs) however this is not the problem addressed in this paper} and every mention of trace differentiation will assume the traces agree on input. The way to differentiate traces is by differentiating their states, but which states? this is not a trivial question since traces can vary in length and order of states. We need a state correspondence for choosing the states to be differentiated within the two traces. We define it as following:

\paragraph{Trace Diff Points} \deflabel{TraceDiffPoints}
Given two traces $\pi$ and $\pi'$, we define a trace index correspondence relation named trace diff points denoted $DP_{\pi}$ as a matching of indexes specifying states in where concrete state delta should be computed. Formally: $DP_{\Pi} \equiv \{(i,i')|i \in {0..|\pi|}, i' \in {0..|\pi'|}\}$. The question of supplying this matching, in a way that results in meaningful delta, is not a trivial one, we delay this discussion until we define the trace delta.

Now that we have a way of matching states to be compared between two traces, we define the notion of trace differentiation:

\paragraph{Trace Delta} \deflabel{ConcreteTraceDelta}
Given traces $\pi,\pi'$ of programs $P,P'$ respectively, and a state correspondence $DP_{\Pi}$ we define the trace delta $\triangle_{T}(\pi,\pi')$ as state differentiations between all corresponding states in $\pi$ and $\pi'$. Formally, for every $(i,i') \in DP$ such that $\triangle_{S}(\sigma_{i},\sigma'_{i'}) \neq \emptyset$, $\triangle_{T}$ will contain the mapping $i \mapsto \triangle_{S}(\sigma_{i},\sigma'_{i'})$, thus the result will map certain states in $\pi$ to their state delta with the corresponding state' in $\pi'$ (deemed interesting by $DP_{\Pi}$). We define $\triangle_{T}^{+}$ and $\triangle_{T}^{-}$ in a similar way.

One possible choice for $DP_{\Pi}$ would be the endpoints of the two traces $\{(fin,fin')\}$ (assuming they are finite) meaning differentiating the final states of the executions or formally: $\triangle_{in}^{-} \equiv \triangle_{Fin}(\pi,\pi') = \{fin\mapsto\triangle_{S}(\sigma_{fin},\sigma'_{fin'})\}$ (we will also be interested in $\triangle_{Fin}^{+}$). It is clear that the delta is not sufficient for truly describing the difference between said traces as it will only compare final state values and will miss out on what happened during the execution. This can be overcome by instrumenting the semantics such that the state will contain all "temporary" values for a variable along with the trace index (program location is not sufficient here as a trace can loop over a certain location) where the values existed by, for instance, adding temporary variables, allowing for a complete differentiation at the end point. This may substantially complicate the selection of $VC$ it will require a matching between all of these temporary, indexed, variables that will somehow produce meaning. Also the number of variables here can range up to the length of the trace.

Defining the $DP$ over any two traces is a daunting task since traces of separate (although similar) programs can vastly differ. If we take a look at two versions of a program depicted in \figref{MatchingProblemExamplePrograms} and the following traces generated from the input $x=2$: $\pi = \{x=2,i=0 \}\{i=1 \}\{i=2 \}$ and $\pi' = \{ x'=2,i'=0 \}\{ i'=1 \}\{ i'=2 \}\{ i'=3 \}\{i'=4\}$ (we omit labels and guard values and only mention parts of the trace where variable values change), we see that even in this simple program, finding a correlation based on traces alone is hard. However, one can get the sense that using program location as a means of correlation, one can produce a meaningful result. For example, if we look at all the possible values for $i$ in label $lab$ and differentiate them (as a set) from the values in the patched version (in the same location), we get a meaningful result that $i$ in the patched version can range from $x+1$ up to $2x$. We will discuss differentiation of sets of states later on as we describe the collecting semantics.

\begin{figure}
\begin{tabular}{cc}
\centering
\begin{lstlisting}
void foo(unsigned x) {
    unsigned i = 0;
lab:guard g = (i >= x);
    if (g) return;
    ...
    i++;
    goto lab;
}
\end{lstlisting}
&
\begin{lstlisting}
void foo'(unsigned x) {
    unsigned i = 0;
lab:guard g = (i >= (*@\textbf{2*x}@*));
    if (g) return;
    ...
    i++;
    goto lab;
}
\end{lstlisting}
\end{tabular}
\figlabel{MatchingProblemExamplePrograms}
\caption{$P,P'$ differentiation candidates}
\end{figure}

\subsection{Differencing at Program Labels} \sublabel{DiffAtLabels}

\paragraph{Trace Delta using Program Label} \deflabel{ProgramLabelTraceDelta}
Given two traces $\pi,\pi'$ and two program labels $l,l'$ we define a trace delta based on all traces locations (states) that are labeled $l,l'$. First we define $\pi_{l}$ as a sub-sequence of $\pi$ where only states that are labeled $l$ were chosen ($\pi'_{l'}$ is defined similarly). Next, we denote $\triangle_L(\pi_{l},\pi'_{l'})$ as a means for comparing these sequences. As $\pi_{l},\pi'_{l'}$ may vary in length and order, we cannot simply define it as applying $\triangle_{S}$ on each pair of states in $(\pi_{l},\pi'_{l'})$ by order. In fact, $\triangle_{L}$ can be defined in different way to reflect different concepts of difference, for instance, it can be defined as the differentiating the last states of $\pi_{l}$ and $\pi'_{l'}$ (assuming they are both finite) to reflect we are only interested in the final values in that location. We chose to define $\triangle_{L}$ as the difference between \emph{the set of states} which appear in $\pi_{l}$ against the set of those in $\pi'_{l'}$. Formally: $\triangle_{L_{set}}(\pi_{l},\pi'_{l'}) \triangleq \{ \sigma \in ran(\pi_{l}) | \neg \exists \sigma' \in ran(\pi'_{l'}) s.t. \triangle_{S}(\sigma,\sigma') = \emptyset \}$. For example, if we look at \figref{MatcingProblemExamplePrograms}, for $\pi, \pi'$ that originate from $x=2$  then $\triangle_{L_{set}}(\pi_{lab},\pi'_{lab'}) = \{\}$ and $\triangle_{L_{set}}(\pi'_{lab'},\pi_{lab}) = \{\{ i'=3 \},\{i'=4\}\}$. We see that this notion of $\triangle$ indeed captures a useful description of difference.

The problem of choosing $DP$ is now reduced to the matching of labels as the trace indexing correspondence $DP_{\Pi}$ defined in \defref{TraceDiffPoints} is no longer needed here. as we need to differentiate sets of states belonging to a certain program label. We require a correspondence of \emph{labels} and therefore we define the label diff points correspondence.

\paragraph{Label Diff Points} \deflabel{LabelDiffPoints}
Given two programs $P,P'$ and their sets of program labels $Lab,Lab'$, we define a label correspondence relation named label diff points denoted $DP_{Lab}$ as a matching of labels between programs. Formally: $DP_{Lab} \equiv \{(l,l')|l \in Lab, l' \in Lab'\}$. From this point on any mention of the diff-points correspondence $DP$ will refer to label diff-points $DP_{Lab}$. We address the question of selection of $DP_{Lab}$ in a meaningful way in \subref{DiffPoints}. %We will briefly mention that in order to find a meaningful correspondence, we employ a standard syntactic diff algorithm~\cite{Diff} on the two versions of the program. Our experiments show that for the purpose of differentiating versions of program, this approach works well since patched versions tend to be syntactically similar (especially when the versions come from two successive check-ins to the code repository).

Now, we will move past the concrete semantics towards a \emph{collecting semantics} as a step towards abstraction. This is required as it is unfeasible to describe difference based on traces. However, we need to adjust our concrete semantics before we can correctly define this as the collecting semantics based on individual traces \textbf{will not allow us to correlate traces that originate from the same input}. This is the first formal indication of how a separate abstraction, that considers each of the programs by itself, cannot succeed.

\subsection{Concrete Correlating Semantics} \sublabel{ConcreteCorrelatingSemantics}

In this section we shortly define, based on previous definitions, the correlating state and trace which bind the executions of both programs, $P$ and $P'$, together and we define the notion of delta there. Essentially, these will be states and traces of the product program $P \times P'$ but only traces that originate from the same input are considered. This will allow us to then define the correlating collecting semantics which is key for successful differencing.

\paragraph{Correlating Concrete State} \deflabel{CorrelatingConcreteState}
A correlating concrete state $\sigma_{\times}$ is a pair of concrete states $(\sigma,\sigma')$ belonging to a pair of programs $P$ and $P'$. The set of all possible correlating states is denoted $\semp{P \times P'}$.

\paragraph{Correlating Concrete Trace} \deflabel{CorrelatingConcreteTrace}
A correlating trace $\pi_{\times}$, is a sequence of correlating states $...,(\sigma_i,\sigma'_j),...$ describing a dual execution of the two programs where at every point each of the program can perform a single step. The $label_{\times}$, $last_{\times}$ and $pre_{\times}$ operations are defined similarly.

\paragraph{Correlating Collecting Semantics of a Program Label} \deflabel{CorrelatingCollectingSemantics}
Given a paired label $l_{\times} = (l,l') \in Lab_{\times}$ in the product program we define the correlating collecting semantics $CS(l_{\times}) \subseteq \semp{P \times P'}$ as all the correlating states which are "possible" at that paired label (i.e. exist in some trace reaching that label), grouped by trace. Formally:
\begin{enumerate}
\item $at_{\times} : (Lab_{\times} \times \Pi_{\times}) \rightarrow 2^{\semp{P \times P'}^*})$ for a given label $l_{\times}$ and trace $\pi_{\times}$, is the set of prefixes of $\pi_{\times}$ that end in a state labeled $l_{\times}$ formally: $at(l_{\times},\pi_{\times}) \triangleq \{\pi_{\times}^* | \pi_{\times}^* \in pre_{\times}(\pi_{\times}) \wedge last_{\times}(\pi_{\times}^*)=l_{\times} \}$.
\item $CS(l_{\times}) \triangleq \{\{last_{\times}(at_{\times}(l_{\times},\pi_{\times}))\} | \pi_{\times} \in \Pi_{\times}\}$.
\end{enumerate}
As mentioned, distinguishing groups of states that arrived from different traces is imperative here, otherwise we could be comparing states that originate from different inputs.

Now we have a collecting semantics that collects dual states from correlating executions only, and distinguishes them by input.

\paragraph{Collecting Semantics Delta} \deflabel{CollectingSemanticsDelta}
As discussed in \subref{DiffAtLabels}, we now calculate difference in locations based on a correspondence of labels $DP$ in $P$ and $P'$. This matches our collecting semantics perfectly as our collecting semantics is defined over paired labels. We compute the collecting semantics delta by applying delta on each $CS(l_{\times})$ for each matched pair of label $(l,l') = l_{\times}$. This is very similar to the label-based trace delta as now we handle \emph{sets} of correlating states (instead of a series of regular states) and we are encountered with the same difficulty. For example, When we compute the collecting semantics for label $(lab,lab')$ in the example from \figref{MatchingProblemExamplePrograms}, we are resulted in $CS(lab,lab') = \{ \{ <(x=0,i=0),(x'=0,i'=0)> \}, \{ <(x=1,i=0),(x'=1,i'=0)>, <(x=1,i=1),(x'=1,i'=0)>, <(x=1,i=0),(x'=1,i'=1)>, <(x=1,i=1),(x'=1,i'=1)>, <(x=1,i=0),(x'=1,i'=2)>, <(x=1,i=1),(x'=1,i'=2)> \}, ... \}$ which indeed groups together all possible states at the desired label according to originating input, but we are still left with the question of how do we calculate delta on each of these groups (for instance the group originating from input $x=1$). Again, this decision is determined by the kind of difference we want to capture. As before, we choose to define differentiation according to sets of states: we will divide each group of dou-states into two sets containing $P$ and $P'$ states, and try to match each of the $P$ states with a single $P'$ state (using $VC$ of course) and vice versa. Formally:
\begin{itemize}
\item for each group of correlating states $\Sigma_{\times}^{i} \in CS(l_{\times})$ (which originated from the same input) we break it into  $\Sigma^{i} = \{\sigma = first(\sigma_{\times}) |  \sigma_{\times} \in \Sigma_{\times}^{i}\}$ and $\Sigma'^{i} = \{\sigma' = second(\sigma_{\times}) |  \sigma_{\times} \in \Sigma_{\times}^{i}\}$.
\item as $\triangle_{CS}$ is directional as well, we denote $\triangle_{CS}^{+}(l_{\times})$ as states of $P'$ at label $l$ that do not exist in $P$ at label $P'$ (grouped by originating input) i.e. added states and formally: $\triangle_{CS}^{+} \triangleq \{ \Sigma'^{i} \setminus \Sigma^{i} | \Sigma_{\times}^{i} \in CS(l_{\times}) \}$. We take notice that the $\setminus$ operation uses $VC$ for comparison.
\item Similarly: $\triangle_{CS}^{-} = \{ \Sigma^{i} \setminus \Sigma'^{i} | \Sigma_{\times}^{i} \in CS(l_{\times}) \}$ for "removed" states.
\end{itemize}

 In the previous example $CS(lab,lab')$, the $x=1$ group will be broken into $\Sigma = \{ (x=1,i=0), (x=1,i=1) \}$ and $\Sigma = \{(x'=1,i'=0), (x'=1,i'=1), (x'=1,i'=2)\}$ which will then be compared to produce $\triangle_{CS}^{+}[x=1] = \{(x'=1,i'=2)\}$ and $\triangle_{CS}^{-}[x=1] = \emptyset$ which successfully describes the difference here as in $P'$ a new state is added.

We must remember however, that the sets of states to be compared are potentially unbounded which means that the delta we compute may be unbounded too. Therefore we must use an abstraction over the collecting semantics that will allow us to represent the collecting semantics in a bounded way.
