\section{Concrete Semantics}\seclabel{ConcreteSem}
In this section, we define the notion of difference between concrete semantics of two programs based on a standard concrete semantics for a program.

\subsection{Concrete State Differencing} \sseclabel{ConcreteDiff}
Comparing two different programs $P$ and $P'$ under our concrete semantics means comparing \emph{traces}. A trace is composed of concrete states thus we first need a way to compare states. We define a state $\sigma$ as a mapping $Var \rightarrow Val$, and a difference between states would be one state mapping a different value to the same variable. But as variables may differ between programs, we require a correspondence between variables in $P$ (i.e. $Var$) and those in $P'$ (i.e. $Var'$) and the difference will be checked over matched variables.

\paragraph{Variable Correspondence} \deflabel{VarCorrespondence}
A variable correspondence $VC \in Var \times Var'$, is a partial mapping between 2 sets of program variables. Any variable in $Var$ may be matched with any in $Var'$ and vice versa. Naturally, the comparison between states will occur between values mapped to corresponding variables, as described by $VC$.

Our analysis may receive a user defined correspondence or use a standard name-base matching: $VC_{EQ} \triangleq \{(v,v') | v \in Var \wedge v' \in Var' \wedge name(v) = name(v')\}$ and vice versa. Our experience suggests that for most patches, the set of variables does not change over subsequent versions ($Var = Var'$) except for perhaps the addition of new variables or removal of an old one. Therefore we concluded that for our purposes, matching variables by name is sufficient for finding a precise difference. %In cases where the matching is not that straightforward, for example, when variables name change, the correspondence can be generated in \TODO{a more sophisticated way}.

%% We give a much more verbose, directional definition for state delta

\paragraph{Concrete State Delta} \deflabel{ConcreteStateDelta}
Given two concrete states $\sigma \in \Sigma_P,\sigma' \in \Sigma_{P'}$ and a variable correspondence $VC$, we define the concrete state delta $\triangle_S(\sigma,\sigma') : \Sigma_{P} \times \Sigma_{P'} \rightarrow 2^{Var \times Val}$ as the part of the state $\sigma$ where corresponding variables do not agree on values (with respect to $\sigma'$). Formally: $\triangle_{S}(\sigma,\sigma') \triangleq \{ (var,val) | (var,var') \in VC \wedge \sigma(var) = val \neq \sigma'(var')\}$. In case there is no observable difference in state we get that $\triangle_{S}(\sigma,\sigma') = \emptyset$. As state delta is directional, we notice that unless it is empty, $\triangle_{S}$ is not symmetric. In fact, the direction in which $\triangle_{S}$ is used has meaning in the context of a program $P$ and a patched version of it $P$. We define $\triangle_{S}^{-} = \triangle_{S}(\sigma,\sigma')$ which means the values of the state that was "removed" in $P'$ and $\triangle_{S}^{+} = \triangle_{S}(\sigma',\sigma)$ which stands for the values added in $P'$.

\paragraph{Example} For instance, given two states $\sigma = (x \mapsto 1,y \mapsto 2,z \mapsto 3)$ and $\sigma' = (x' \mapsto 0,y' \mapsto 2,w' \mapsto 4)$ and using $VC_{EQ}$ then $\triangle_{S}^{-} = (x \mapsto 1)$ since x and x' match and do not agree on value, y and y' agree (thus are not in delta) and z' is not in $VC_{EQ}$. Similarly, $\triangle_{S}^{+} = (x' \mapsto 0)$. %We believe that $\triangle_{S}$ is a precise and natural definition for difference as it indeed captures the change made in the patched version. We will later on extend the definition to describe difference between abstract states.

We defined a notion for difference between states but this is insufficient to describe difference between program traces. Program equivalence is defined as behavior, or output, equivalence given the \textbf{the same input}. Therefore we are only interested in comparing traces that originate from the same input (for the input variables correlated by $VC$).\COMMENT{ although one can contemplate the question of delta between \emph{any} two traces of a program (or two programs) however this is not the problem addressed in this paper} Every mention of trace differentiation will assume the traces agree on input. The way to differentiate traces is by differentiating their states, but which states? this is not a trivial question since traces can vary in length and order of states. We need a mapping for choosing the states to be differentiated within the two traces. We define it as following:

\paragraph{Trace Diff Points} \deflabel{TraceDiffPoints}
Given two traces $\pi \in \semp{P}$ and $\pi' \in \semp{P'}$ that originate from the same input, we define a trace index correspondence relation named trace diff points denoted $DP_{\pi}$ as a matching of indexes specifying states where concrete state delta should be computed. Formally: $DP_{\pi} \subseteq \{(i,i')|i \in {0..|\pi|}, i' \in {0..|\pi'|}\}$. The question of supplying this matching, in a way that results in meaningful delta, is not a trivial one, we delay this discussion until we define the trace delta.

Now that we have a way of matching states to be compared between two traces, we define the notion of trace differentiation:

\paragraph{Trace Delta} \deflabel{ConcreteTraceDelta}
Given two traces $\pi \in \semp{P}$ and $\pi' \in \semp{P'}$ that originate from the same input, and a state correspondence $DP_{\pi}$ we define the trace delta $\triangle_{T}(\pi,\pi') : \semp{P} \times \semp{P'} \rightarrow (Loc \rightarrow 2^{Var \times Val})$ as state differentiations between all corresponding states in $\pi$ and $\pi'$. Formally, for every $(i,i') \in DP_{\pi}$ such that $\triangle_{S}(\sigma_{i},\sigma'_{i'}) \neq \emptyset$, $\triangle_{T}$ will contain the mapping $i \mapsto \triangle_{S}(\sigma_{i},\sigma'_{i'})$, thus the result will map certain states in $\pi$ to their state delta with the corresponding state' in $\pi'$ (deemed interesting by $DP_{\pi}$). We define $\triangle_{T}^{+}$ and $\triangle_{T}^{-}$ in a similar way.

One possible choice for $DP_{\pi}$ would be the endpoints of the two traces $\{(fin,fin')\}$ (assuming they are finite) meaning differentiating the final states of the executions or formally: $\triangle_{fin}^{-} \triangleq \triangle_{fin}(\pi,\pi') = \{fin\mapsto\triangle_{S}(\sigma_{fin},\sigma'_{fin'})\}$ (we will also be interested in $\triangle_{fin}^{+}$). The final state delta may not always be sufficient for truly describing the difference between said traces as according to our definition of difference, we would be interested in checking difference at intermediate locations in the program (that emit output or check assertions). $\triangle_{fin}$ will only compare final state values and could miss what happened during the execution. This can be overcome by instrumenting the semantics such that the state will contain all "temporary" values for a variable along with the trace index (program location is not sufficient here as a trace can loop over a certain location) where the values existed by, for instance, adding temporary variables, allowing for a complete differentiation at the end point. This may substantially complicate the selection of $VC$ as it will require a matching between all of these temporary, indexed, variables. Such a correspondence may be extremely hard to produce. Also the number of variables here can range up to the length of the trace.

Defining the $DP$ over any two traces is a daunting task since traces of separate (although similar) programs can vastly differ. If we take a look at two versions of a program depicted in \figref{MatchingProblemExamplePrograms} and the following traces generated from the input $x=2$: $\pi = \langle (x \mapsto 2,i \mapsto 0, g \mapsto 0),(x \mapsto 2,i \mapsto 1, g \mapsto 0),(x \mapsto 2,i \mapsto 2, g \mapsto 1) \rangle$ and $\pi' = \langle (x \mapsto 2,i \mapsto 0, g \mapsto 0),(x \mapsto 2,i \mapsto 1, g \mapsto 0),(x \mapsto 2,i \mapsto 2, g \mapsto 0),(x \mapsto 2,i \mapsto 3, g \mapsto 0),(x \mapsto 2,i \mapsto 4, g \mapsto 1)\rangle$, we see that even in this simple program, finding a correlation based on traces alone is hard. However, one can get the sense that using program location as a means of correlation, one can produce a meaningful result that describes how the values of $i$ range differently in the new version $P$. For example, if we look at all the possible values for $i$ in label $lab$ and differentiate them (as a set) from the values in the patched version (in the same location), we get a meaningful result that $i$ in the patched version can range from $x+1$ up to $2x$. We will discuss differentiation of sets of states later on as we describe the collecting semantics.

\begin{figure}
\begin{tabular}{cc}
\centering
\begin{lstlisting}
void foo(unsigned x) {
    unsigned i = 0;
lab:guard g = (i >= x);
    if (g) return;
    ...
    i++;
    goto lab;
}
\end{lstlisting}
&
\begin{lstlisting}
void foo'(unsigned x) {
    unsigned i = 0;
lab:guard g = (i >= (*@\textbf{2*x}@*));
    if (g) return;
    ...
    i++;
    goto lab;
}
\end{lstlisting}
\end{tabular}
\figlabel{MatchingProblemExamplePrograms}
\caption{$P,P'$ differentiation candidates}
\end{figure}

\subsection{Differencing at Program Labels} \sseclabel{DiffAtLabels}

\paragraph{Trace Delta using Program Label} \deflabel{ProgramLabelTraceDelta}
Given two traces $\pi,\pi'$ and two program labels $l,l'$ we define a trace delta based on all trace locations (states) that are labeled $l,l'$. First we define $\pi_{l}$ as a sub-sequence of $\pi$ where only states that are labeled $l$ were chosen ($\pi'_{l'}$ is defined similarly). Next, we denote $\triangle_L(\pi_{l},\pi'_{l'})$ as a means for comparing these sequences. As $\pi_{l},\pi'_{l'}$ may vary in length and order, we cannot simply define it as applying $\triangle_{S}$ on each pair of states in $(\pi_{l},\pi'_{l'})$ by order. In fact, $\triangle_{L}$ can be defined in different way to reflect different concepts of difference, for instance, it can be defined as the differentiating the last states of $\pi_{l}$ and $\pi'_{l'}$ (assuming they are both finite) to reflect we are only interested in the final values in that location. We chose to define $\triangle_{L}$ as the difference between \emph{the set of states} which appear in $\pi_{l}$ against the set of those in $\pi'_{l'}$. Formally: $\triangle_{L_{set}}(\pi_{l},\pi'_{l'}) \triangleq \{ \sigma \in ran(\pi_{l}) | \neg \exists \sigma' \in ran(\pi'_{l'}) s.t. \triangle_{S}(\sigma,\sigma') = \emptyset \}$. For example consider \figref{MatcingProblemExamplePrograms}, for $\pi, \pi'$ that originate from $x=2$  then $\triangle_{L_{set}}(\pi_{lab},\pi'_{lab'}) = \emptyset$ and $\triangle_{L_{set}}(\pi'_{lab'},\pi_{lab}) = \{ (i' \mapsto 3),(i' \mapsto 4) \}$. We see that this notion of $\triangle$ indeed captures a useful description of difference.

The problem of choosing $DP$ is now reduced to the matching of labels as the trace indexing correspondence $DP_{\pi}$ defined in \defref{TraceDiffPoints} is induced by the definition over labels. as we need to differentiate sets of states belonging to a certain program label. We require a correspondence of \emph{labels} and therefore we define the label diff points correspondence.

\paragraph{Label Diff Points} \deflabel{LabelDiffPoints}
Given two programs $P,P'$ and their sets of program labels $Lab,Lab'$, we define a label correspondence relation named label diff points denoted $DP_{Lab}$ as a matching of labels between programs. Formally: $DP_{Lab} \subseteq \{(l,l')|l \in Lab, l' \in Lab'\}$. From this point on any mention of the diff-points correspondence $DP$ will refer to label diff-points $DP_{Lab}$. We address the question of selection of $DP_{Lab}$ in \subref{DiffPoints}. %We will briefly mention that in order to find a meaningful correspondence, we employ a standard syntactic diff algorithm~\cite{Diff} on the two versions of the program. Our experiments show that for the purpose of differentiating versions of program, this approach works well since patched versions tend to be syntactically similar (especially when the versions come from two successive check-ins to the code repository).

Now, we will move past the concrete semantics towards a \emph{collecting semantics} as a step towards abstraction. This is required as it is unfeasible to describe difference based on traces. However, we need to adjust our concrete semantics before we can correctly define this as the collecting semantics based on individual traces \textbf{will not allow us to correlate traces that originate from the same input}. This is the first formal indication of how a separate abstraction, that considers each of the programs by itself, cannot succeed.

\subsection{Concrete Correlating Semantics} \sseclabel{ConcreteCorrelatingSemantics}

In this section we shortly define, based on previous definitions, the correlating state and trace which bind the executions of both programs, $P$ and $P'$, together and we define the notion of delta there. Essentially, these will be states and traces of the product program $P \times P'$ but \textbf{only traces that originate from the same input are considered}. This allows us to then define the correlating abstract semantics which is key for successful differencing.

\paragraph{Correlating Concrete State} \deflabel{CorrelatingConcreteState}
A correlating concrete state $\sigma_{\times} : Var \cup Var' \rightarrow Val$ is a join of concrete state, mapping variables from a pair of programs $P$ and $P'$ to their values. The set of all possible correlating states is denoted $\Sigma_{P \times P'}$.

\paragraph{Correlating Concrete Trace} \deflabel{CorrelatingConcreteTrace}
A correlating trace $\pi_{\times}$, is a sequence of correlating states $...,<\sigma^{i}_{\times}>,...$ describing a dual execution of the two programs where at every point each of the program can perform a single step. The $label_{\times}$, $last_{\times}$ and $pre_{\times}$ operations are defined similarly. We denote by $\semp{P \times P'}$ the set of all traces in $P \times P'$. Again, we restrict to traces that originate from the same input i.e. $\sigma_0 =_{VC} \sigma'_0$.

We must remember however, that the number of traces to be compared is potentially unbounded which means that the delta we compute may be unbounded too. Therefore we must use an abstraction over the concrete semantics that will allow us to represent executions in a bounded way.
