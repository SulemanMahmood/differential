\section{Our Approach} \label{Sec:OurApproach}

%----------------Game plan-----------------------------------------
Our approach consists of the following steps:
\begin{itemize}
\item \ref{SubSec:Correlation}: Defining differential analysis as correlation between versions of variables.
\item \ref{SubSec:Union}: Creating facilities for performing such analysis using a "union" program.
\item \ref{SubSec:Delta}: Computing abstract values for the differential using several domains.
\item \ref{SubSec:Input}: Extracting concrete input values that lead to the states in the differential.
\end{itemize}

\subsection{Differential Analysis As Correlation Between the Old and the New}\label{SubSec:Correlation}
%----------------It's better to analyze the delta directly--------
We observe that $\asemp{P}\setminus \asemp{P\oplus X}$ does not maintain correlations between old program variable values and new ones. Such relationships are critical for identifying the differential (abstract) values. We therefore consider $\triangle = \asemp{P \cup X}$ which holds values only for relationships of the 2 versions of each variable. This will always be more precise than $\asemp{P}\setminus \asemp{P\oplus X}$.

%----------------The delta is achieved using the union program--------
$\triangle$ is computed over $P \cup X$. We therefore first define how to compute $P \cup X$ which is a union program constructed out of $P$ and $X$ that holds 2 versions for each variable: one representing the variable in the original program $P$ and one representing the variable in the patched program $P \oplus X$. This essentially allows use to analyze the old program variable values alongside the new ones.

%----------------Demonstration--------
To demonstrate this we bring the following example:
\begin{figure}[H]
\begin{lstlisting}
for (int i = 0 ; i < end ; i ++) {
    // Pre patch value for size
-   const int size = i;
    // Post patch value for size
+   const int size = 2*i;
    int Buff[size];
    // Do something on Buff
    ...
}
\end{lstlisting} \caption{Pre and post patch variable data relationship analysis demonstration}
\end{figure}

In this example, if we use the linear inequalities abstract domain we will deduce that $\asemp{P}(size) := 0 \leq size \leq end$ and  $\asemp{P \oplus X}(size') := 0 \leq size' \leq 2*end $ (we denote the patched version of the \scode{size} variable as \scode{size'}. The much more precise observation is that $\asemp{P \cup X}(size,size') :=  size' = 2size $. This correlation could not be maintained in $\asemp{P} \setminus \asemp{P \oplus X}$ due to the limitations of the abstract domain. Our intuition is that theoretically, $\asemp{P} \setminus \asemp{P \oplus X}$ will always hold less information than $\triangle$.

\subsection{Constructing $P \cup X$ }\label{SubSec:Union}
We will describe an algorithm for constructing the union program. As said, the main idea is to duplicate every variable that is affected by the patch (a line added or removed by the patch affects it directly or subsequently) thus we get a representation for the original program variables and the patched program variables.
In order to correctly apply the algorithm we first need to transform the program into a "guarded instruction" format (algorithm described in \ref{Sec:Appendix}) which allows us to interleave original program lines and patch lines (removed or added) without disturbing the correctness of loops and branched. A guarded instruction program contains only 1-level (no nesting) branches and all loops are implemented using goto statements (example in \ref{SubSec:GuardedAlg}).

\subsubsection{Algorithm 1 : Construct $P \cup X$} \label{SubSubSec:UnionAlg}
\begin{enumerate}
\item Transform $P$ to a "guarded instruction" type program (as described in \ref{SubSec:GuardedAlg})
\item Calculate all the variables affected (directly or indirectly) by the patch denoted by $V_{patch}$. Create a duplicate version for each of these variables.
\item For each guarded instruction $I$: If $I$ references a variable in $V_{patch}$ then duplicate $I$ while replacing every variable reference with it's patched version.
\item Leave all lines removed by the patch (they will affect the original version alone)
\item Add all the lines added by the patch while replacing all references to variables with references to the patched version of the variables (they will affect the patched version alone).
\end{enumerate}

A sample run of the algorithm can be found in \ref{SubSec:UnionAlgEx}.

\subsubsection{Algorithm 1 Assumptions}
We assume the following on the program $P$ and patch $X$ (for now):
\begin{enumerate}
\item $X$ does not rename variables
\item $X$ keeps all variables in $P$
\end{enumerate}
Some of these assumptions can be relaxed later on.

\subsection{Computing $\triangle$} \label{SubSec:Delta}
As described before, we cannot compute all the concrete states of a program and it's patched counter part. Therefore we compute $\triangle$ which is an over approximation of the concrete states i.e. abstract states which only addresses differences between states created by the patch and more precisely the relationship between variables in states before the patch and after the patch.
In order to compute an over approximation we use abstract values to represent groups of concrete values for program values. Abstract values are taken from a certain domain and we choose 2 abstract domains, one relatively simple, and one relatively complex, for capturing $\triangle$:

\subsubsection{Integers Intervals}
Instead of holding all the concrete possible values for an integer, we hold only a range $[a,b]$ for it i.e. its maximum and minimum possible values.
A proposed analysis for \ref{SubSec:LinuxOBT}:
\begin{figure}[H]
\begin{lstlisting}
size_t rpc_uaddr2sockaddr(const char *uaddr, const size_t uaddr_len,
                          const size_t uaddr_len', struct sockaddr *sap, const size_t salen) {
  char *c, buf[RPCBIND_MAXUADDRLEN], buf'[RPCBIND_MAXUADDRLEN];
  ...
  if (uaddr_len > sizeof(buf)) return 0;
  // MIN_INT <= uaddr_len <= RPCBIND_MAXUADDRLEN
  if (uaddr_len' > sizeof(buf) - 2) return 0;
  // MIN_INT <= uaddr_len' <= RPCBIND_MAXUADDRLEN - 2
  ...
  buf[uaddr_len] = '\n';
  buf'[uaddr_len'] = '\n';
  buf[uaddr_len + 1] = '\0';
  buf'[uaddr_len' + 1] = '\0';
  ...
}
\end{lstlisting}\caption{Integer interval analysis for the Linux Kernel Function \scode{rpc\_uaddr2sockaddr()} off-by-two bug.}
\end{figure}
This relatively simple analysis successfully captures the differentiation between the variables values before and after the patch and can be easily used to deduce the offending values removed by the patch (\scode{uaddr\_len = RPCBIND\_MAXUADDRLEN - 1,uaddr\_len = RPCBIND\_MAXUADDRLEN - 2}).
It's not hard to imagine a case where this analysis domain fails at producing useful data for tracking down offending values and a more sophisticated domain is needed, therefore a we introduce the linear inequalities domain into our analysis.

\subsubsection{Linear Inequalities}
This is a more complex domain which holds equalities and inequalities for variable values. By it's nature, this domain is more powerful, which enables us to contain significantly more data on relationships between program variables and specifically, the relationship between the old and the new.
We use Min\'{e}'s octagon abstract domain \cite{Octagon} and it's implementation in the APRON library for computing analysis data in this abstract domain.
A proposed analysis for \ref{SubSec:FirefoxBO}:
\begin{figure}[H]
\begin{lstlisting}
nsresult nsGenericDOMDataNode::SetTextInternal(PRUint32 aOffset, PRUint32 aCount,
    PRUint32 aCount', const PRUnichar* aBuffer, PRUint32 aLength, PRUint32 aLength', PRBool aNotify) {
    PRUint32 textLength = mText.GetLength(), textLength' = mText.GetLength();
    PRInt32 newLength = textLength - aCount + aLength;

    PRUnichar* to = new PRUnichar[newLength];

    if (aCount' > textLength' - aOffset) aCount' = textLength' - aOffset;

    if (aLength' > aCount' && (unsigned)(textLength' - aCount' + aLength') > (1 << 29))
        return NS_ERROR_DOM_DOMSTRING_SIZE_ERR;

    // (unsigned)(textLength' - aCount' + aLength') < (1 << 29)
    // (unsigned)(textLength - aCount + aLength) >= (1 << 29)

    if (aLength)
        memcpy(to + aOffset, aBuffer, aLength * sizeof(PRUnichar));

}
\end{lstlisting}\caption{Linear inequalities analysis for Firefox's Heap Buffer Overflow On 64Bit Systems}
\end{figure}
The inequality \scode{(unsigned)(textLength - aCount + aLength) >= (1 << 29)} is key in deriving values for said variables and exposing the bug. This cannot be achieved using the interval domain since we have no numerical constant basis from which we can resolve useful interval information and all intervals will range between the minimum possible value and the maximum one.


\subsection{Refining $\triangle$}
We present an algorithm for refining $\triangle$ in a way that produces 2 results: one over-approximation for the \emph{lost states} of the program (states existing in the original program but no longer in the patched one) and another for the \emph{new states} of the program. These are denoted by $\triangle^-$ and $\triangle^+$ respectively. An important observation is that $\triangle^-$ and $\triangle^+$ are in fact a set of abstract states, each defining a different group of the lost or created concrete program states, this is also derived from our algorithm implementation. \ref{Fig:AbstractNegation} depicts the set of abstract states composing the lost and create in a polyhedra domain.

\begin{figure}[H] \label{Fig:NewLostStates}
\caption{Lost and New States Deduction for Abstract State in Polyhedra Domain}
\end{figure}

\para{Algorithm Description} \\
\para{Input:} $\triangle$ which holds abstract values for the original program variables and their patched counterparts \emph{V,V'} \\
\para{Output:} 1. The lost program states $\triangle^-$ as a set of abstract states. 2. The new program states $\triangle^+$ as a set of abstract states. \\
\para{Body:}
\begin{enumerate}
\item Compute the sub-state $R$ of $\triangle$ representing $\asemp{P} \cap \asemp{P\oplus X}$ i.e. the concrete states shared by the original and patched program. This is achieved by performing: $R = \triangle \sqcap \bigwedge\{v \in V, v' \in V' | v = v'\}$
\item Separate $R$ into 2 abstract states: $R^- = R|V$ by forgetting all  $v' \in V'$ (without losing unnecessary precision) and $R^+ = R|V'$
\item Break abstract states into individual constraint as such: $\varphi^- = \{ c \in R^- | c \}$ and $\varphi^+ = \{ c \in R^+ | c \}$
\item Negate each of the constraints: $ \overline{\varphi^-} = \{ c \in \varphi^- | \neg c \}$ and $\overline{\varphi^+} = \{ c \in \varphi^+ | \neg c \}$
\item The set of abstract states composing $\triangle^-$ ($\triangle^+$) is the result of meeting each of the constraints in $\overline{\varphi^-}$ ($\overline{\varphi^+}$) with $\triangle$:\\
    $\triangle^- = \{ c \in \overline{\varphi^-} | \triangle \sqcap \{ c \} \}$ \\
    $\triangle^+ = \{ c \in \overline{\varphi^+} | \triangle \sqcap \{ c \} \}$
\end{enumerate}

We extend out algorithm to adhere to a domain of sets of abstracts where the logic of our new domain is this: a state in the domain is a group of abstracts. each abstract is a conjunction of constraints and all of the abstracts are disjuncted i.e. either one of the abstracts is true - but all constraints in the abstract must hold at once.

\para{Algorithm Description} \\
\para{Input:} $\triangle = \{\delta_1,...,\delta_n\}$ which is a \emph{set} of abstract states $\delta_i$ holding values for the original program variables and their patched counterparts \emph{V,V'}.\\
\para{Output:} 1. The lost program states $\triangle^-$ as a set of abstract states. 2. The new program states $\triangle^+$ as a set of abstract states. \\
\para{Body:}
\begin{enumerate}
\item Compute the sub-state $R$ of $\triangle$ representing $\asemp{P} \cap \asemp{P\oplus X}$ i.e. the concrete states shared by the original and patched program. This is achieved by performing: $R = \{\delta_i \in \triangle | ( \delta_i \sqcap \bigwedge\{v \in V, v' \in V' | v = v'\} )\} = \{ \tau_1, ..., \tau_n \}$
\item Separate $R$ into 2 sets: $R^- = R[V] = \{\tau_i \in R | \tau_i[V] \} = \{ \tau_1^-,..., \tau_n^- \}$ by forgetting all  $v' \in V'$ (without losing unnecessary precision) and $R^+ = R[V']$
\item Break and negate each abstract state in the set into a set of individual negated constraints as such: $\overline{\tau_i^-} = \{ c \in \tau_i^- | \{\neg c\} \} = \{ \overline{\tau_{i,1}^-}, ... ,\overline{\tau_{i,m}^-} \}$ and $\overline{\tau_i^+}$. This adheres to the logic of our new domain: the negation of a single abstract (a conjunction of constraints) results in a group of disjuncted singletons composed of the constraints in said abstract.
\item For each group $\overline{\tau_i^-}$ of disjuncted constraints, compute the disjunction of each constraints with \emph{all} other constraints in the remaining $\overline{\tau^-}$'s:
$ \Phi^- = \{j_1 \in \{1..m_1\}, j_2 \in \{1..m_2\} ..., j_n \in \{1..m_n\} | \overline{\tau_{1,j_1}^-} \sqcap \overline{\tau_{2,j_2}^-} \sqcap ... \sqcap \overline{\tau_{n,j_n}^-} \} = \{ \varphi_1^-, ... ,\varphi_l^- \}$ where $m_{index}$ is the size of $\overline{\tau_{index}^-}$.
\item The set of abstract states composing $\triangle^-$ ($\triangle^+$) is the result of meeting each of the abstracrts in $\Phi^-$ ($\Phi^+$) with each of the abstracts in $\triangle$:\\
    $\triangle^- = \{ \delta_i \sqcap \varphi_k^- \}$
\end{enumerate}

\subsection{Input Extraction} \label{SubSec:Input}
We still need to address the second part of our problem definition. Calculating $\triangle$ is not enough, we wish to produce input values (function parameters assignment) that lead to states in $\triangle^-$ (if possible). This can be achieved in various ways:
\begin{itemize}
\item Erez, Yahav and Sagiv \cite{InputGen} work on symbolic backward execution.
\item As preliminary work, we used a module for performing analysis using bounded symbolic execution on top of the CLang infrastructure \cite{CLang}. As we ran the analysis from the procedure entry forward to symbolically execute the program and get abstract values for program variables at each point, the analysis may also run backwards from a certain program point and variable assignment to find the weakest precondition \cite{kn:Dijkstra} for the input.
\item Our own data flow analysis, which also relies on the CLang infrastructure \cite{CLang} may also be run backwards to produce the desired input.
\end{itemize}
