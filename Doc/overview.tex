\section{Overview} \seclabel{Overview}

In this section, we informally describe our approach with a simple example program.

\subsection{Motivating Example}

\figref{MotivatingLoopExample} shows a looping code fragment and its patched version. We aim to find semantic differences between these versions which optimally would be the result where after the \scode{y = x} statement in the original version and after the \scode{y = x + 1} statement in the patched program, $y$ will assume a value that is greater by 1 and also that \textbf{no difference exists up to that point}.

\begin{figure}[ht]\figlabel{MotivatingLoopExample}
\lstset{numbers=left, language=C, basicstyle=\ttfamily\scriptsize,emph={},emphstyle=\textbf,escapechar=\%}
\begin{minipage}[b]{0.5\linewidth}
\centering
\begin{lstlisting}
while (x>0) {
    x--;
}
y = x;
\end{lstlisting}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.5\linewidth}
\centering
\begin{lstlisting}
while (x>0) {
    x++;
    x-=2;
}
y = x + 1; // Patch
\end{lstlisting}
\end{minipage}
\caption{example looping code and patched version}
\end{figure}

One might consider performing a separate analysis on each of these procedures and comparing the results (i.e. the abstract state at a program location) to check for difference (we temporarily ignore the question of program location matching for the sake of argument). As we are dealing with over-approximations, it would be impossible to claim equivalence based on two separate states: say we would like to compare the two states right after exiting the loop. Optimally, these states will both contain the ${x<=0}$ constraint. Though it would be tempting to claim that the programs are equivalent at this point, it would be wrong, as each program may have arrived at the ${x<=0}$ constraint by entirely different means. For instance, one could be the result of a joining ${-5<=x<=0}$ and ${x<=-10}$, and the other could be the result of joining ${x=0}$ and ${x<=-1}$. This key observation, which basically states that \emph{equality under abstraction does not assure concrete equality}, dictates the use of a combined analysis as otherwise we can never hope to establish equivalence.

One option for performing this combined, correlating analysis is by defining a special correlating semantics which requires performing a dual analysis on both programs, whilst maintaining abstract information regarding variables of both programs together. Although being a viable option, we chose a different approach where we would simply construct a single correlating program, denoted $P \bowtie P'$ (for the correlation of a program $P$ and it's patched version $P'$), that will hold the variables and statements of the two programs and interleave them in such a way where matching statements (that appear in both versions) will be adjacent. We keep the variables of the programs separated by tagging all variables from the newer version. We opted for the correlating program solution since it allows us to employ standard analysis frameworks \cite{CLang} with standard abstract analysis domains \cite{JeannetMine09}. Another advantage is that the correlating program building process supplies us with a matching of program locations, thus we are able to check for difference at appropriate locations. Lastly, since $P \bowtie P'$ is a syntactically correct program, that contains the semantic of both programs, we are able to use existing techniques of symbolic execution and equivalence checking, as used in previous work \cite{GodlinStrichman09,DwyerElbaumPerson08,EnglerRamos11}, \TODO{to achieve potentially better results}, as we allow for a more fine-grained checking and differencing (as opposed to input-output checking). We will elaborate on these issues, and on the process of building the correlating program in \secref{Correlating}.



%Our goal is to describe semantic difference between two programs (program versions) $P,P'$ at certain program points i.e. given two programs and two locations in the programs, we want to produce all program states that are possible at the given location in one program but do not exist in the other program and vice versa.

%Immediately we are encountered with the question of supplying these program locations so that our comparison of states will give a meaningful result \TODO{example}. We calculate the program locations by using a syntactic diff algorithm on a canonicalized form of the input programs as described in \subref{DiffPoints}.

%Next, we need to give meaning to state difference and find an abstraction for precisely capturing the difference. In \secref{ConcreteSem} we define \emph{delta} (denoted $\triangle$) as an operator for describing an producing a meaningful difference of two given states. In \secref{AbstractSem} we define an abstraction for capturing difference and establishing equivalence. We abstract \emph{relationships} between (variables in) states of the two programs and note that non-relational abstractions cannot \emph{soundly} establish equivalence as equality under abstraction does entail concrete equality \TODO{example}.

%Since we use a relational abstract domain for capturing variable relationships, we need a special sort of program or a different semantics for abstracting the programs together. In \secref{Se:Union} we discuss the \emph{union program} $P \cup P'$ which allows us to abstract both program using standard single program semantics and analysis. As mentioned, $P$ and $P'$ relationships could be described by some correlating semantics derived from interpreting both programs simultaneously but we chose to maintain standard semantics and build a joint program as we gain other options for analysis through it as described in \subref{}.

