\section{Correlating Program} \seclabel{Correlating}

In this section we describe how we construct a correlating program $P \bowtie P'$. The process of correlating attempts to find a interleaving of programs for a more precise differentiation. The building process also instruments $P \bowtie P'$ with the required correlation points $CP$ which define the locations for our partitioning. We also allow a user defined selection of $CP$.

\subsection{Construction of $P \bowtie P'$ }\sseclabel{CorrelatingProgramConstruction}
The idea of a correlating program is similar to that of
self-composition~\cite{AikenTerauchi05}, but the way in
which statements in the correlating program are combined is designed to
keep the steps of the two programs close to each other. Analysis of the correlating program can then recover equivalence between values of correlated variables even when
equivalence is \emph{temporarily} violated by an update in one version, as
the corresponding update in the other version follows shortly thereafter.

We will generally describe the process of constructing the correlating program. The correlating program is an optimized reduction over $P \times P'$ where not all pairs of $(\A{\sigma},\A{\sigma'})$ are considered, but only pairs that result from a controlled execution, where correlating instructions in $P$ and $P'$ will execute adjacently. This will allow for superior precision.

The input for the correlation process are two program $(P,P')$ in C\footnote{The C programming language}. The first step involves transforming both programs to a normalized guarded instruction form $(P_{G},P'_{G})$. Next, a vector of \emph{imperative commands} $I$ (and $I'$ respectively) is extracted from each program for the purposes of performing the syntactic diff. An imperative command in our GCL format is defined to be either one of \scode{v := e | goto l | f(...)} as they effectively change the program state (variable values, excluding guards) and control. \TODO{Function calls are either inlined, in case equivalence could not be proven for them, or left as is, in case they are equivalent or are external system calls.} Continuing the construction process, a syntactical diff~\cite{HuntMcIlroy75} is computed over the vectors $(I,I')$. One of the inputs to the diff process is $VC$ as it is needed to identify correlated variables and the diff comparison will regard commands differing by variable names which are correlated by $VC$ as equal. The result of the last step will be a vector $I_{\diff}$ specifying for each command in $I,I'$ whether it's an added command in $P'$ (for $I'$) marked $+$, a deleted command from $P$ (for $I$) marked $-$, or a command existing in both versions marked $=$. This diff determines the order in which the commands will be interleaved in the resulting $P \bowtie P'$ as we will iterate over the result vector $I_{\diff}$ and use it to construct the correlating program. We remind that since $I,I'$ contain only the imperative commands, we cannot use it directly as $P \bowtie P'$. Instead we will use the imperative commands as markers, specifying which chunk of program from $P_G$ or $P'_G$ should be taken next and put in the result. The construction goes as follows: iterate over $I_{\diff}$ and for every command $c$ ($c'$) labeled $l_c$ ($l_{c'}$):
\begin{itemize}
\item read $P_G$ ($P'_G$) up to label $l_c$ ($l_{c'}$) including into block $B_c$ ($B_c'$)
\item for $B_c'$, tag all variables in the block.
\item emit the block to the output.
\item delete $B_c$ ($B_c'$) from $P_G$ ($P'_G$).
\end{itemize}
The construction is now complete. We only add that at the start of the process, we strip $P'_G$ of its prototype and add declarations for the tagged input variables, initializing them to the untagged version (thus assuring $P \correlate P'$ will only co-execute traces that originate from the same input for $P$ and $P'$).
As mentioned $CP$ is also a product of the construction, and it's defined using $=$ commands: after two $=$ commands are emitted to the output, we add an instrumentation line, telling the analysis of the correlation point.
One final observation regarding the correlating program is that it is a legitimate program that can be run to achieve the effect of running both versions. We plan to leverage this ability to use dynamic analysis and testing techniques such as fuzzing~\cite{NethercoteSeward07} and directed automated testing~\cite{CadarDunbarEngler08} on the correlating program in our future work.
