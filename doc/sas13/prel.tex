\section{Preliminaries} \seclabel{Preliminaries}
We use the following standard concrete semantics definitions for a program:
\begin{itemize}
\item $Var,Val,Loc$ denote the set of program variable identifiers, variable values and program locations respectively. Program locations are also denoted $lab$ for label. The labels $begin$ and $end$ mark the start and exit locations of the program.
\item A concrete program state $\sigma$ is a tuple $(loc, values) \in \Sigma$ mapping the set of program variables to their concrete value at a certain program location $loc$. The set of all possible states of a program $P$ is denoted $\Sigma_{P}$.
\item We describe an imperative program $P$, as a tuple $(Val,Var,\rightarrow,\Sigma_{0})$ where $\rightarrow : \Sigma_{P} \times \Sigma_{P} $  is a transition relation and $\Sigma_{0}$ is a set of initial states of the program.
\item A program trace $\pi \in \Sigma^*_{P}$, is a sequence of states $\langle \sigma_0,\sigma_1,... \rangle$ describing a single execution of the program. The set of all possible traces for a program is denoted $\semp{P}$. We also define $last : \Sigma_{P}^* \rightarrow \Sigma_{P}$ which returns the last state in a trace.
\end{itemize}

%\para{Program Location / Label} %\deflabel{ProgramLabel}
%A program location $loc \in Loc$, also referred to as label denoted $lab$, is a unique identifier for a certain location in a program corresponding to the value of the program counter at a certain point in the execution of the program. We also define two special labels for the start and exit locations of the program as $begin$ and $end$ respectively.
%
%\para{Concrete State} %\deflabel{ConcreteState}
%Given a set of variables $Var$, a set of possible values for these variables $Val$ and the set of locations $Loc$, a \emph{concrete program state} is a tuple $\sigma \triangleq \langle loc, values \rangle \in \Sigma$ mapping the set of program variables to their concrete value at a certain program location $loc$ i.e. $values : Var \rightarrow Val$. The set of all possible states of a program $P$ is denoted $\Sigma_{P}$.

\begin{sloppypar}
%\para{Program} \deflabel{Program}
We note that our formal semantics need not deal with errors states therefore we ignore crash states of the programs, as well as inter-procedural programs since our work deals with function calls by either assuming output-equivalence (for functions that were proven to be equivalent) or by inlining them (this work excludes recursion).
\end{sloppypar}

%\para{Concrete Trace} \deflabel{ConcreteTrace}
%A program trace $\pi \in \Sigma^*_{P}$, is a sequence of states $\langle \sigma_0,\sigma_1,... \rangle$ describing a single execution of the program. Every program can be described by the set of all possible traces for its run $\semp{P} \subseteq \Sigma^*$. We also define the following standard operations on traces:
%\begin{itemize}
%\item $label : \Sigma_{P} \rightarrow Lab$ returns the program label of a state.
%\item $last : \Sigma_{P}^* \rightarrow \Sigma_{P}$ returns the last state in a trace.
%\item $pre : \semp{P} \rightarrow 2^{\Sigma_{P}^*}$ returns the set of all prefixes of a trace.
%\item $states : \semp{P} \rightarrow 2^{\Sigma_{P}}$ returns the set of states the trace is composed of.
%\end{itemize}

%As we are addressing the semantics of two programs, we define the \emph{product state} $\sigma_{\times} \in \Sigma_{P \times P'}$ as a pair of states $\langle \sigma,\sigma' \rangle$, the \emph{product program} $P \times P'$ as a product of the transition systems of the underlying programs and \emph{product trace} as a sequence of product states.

