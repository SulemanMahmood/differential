\section{Related Work} \seclabel{Related}

Our work has been mainly inspired by recent work identifying program differencing as having vast security implications~\cite{BrumleyPoosankamSongZheng08,SongSunZhang09} as well as advancements made in the field of under-approximations of program equivalence~\cite{GodlinStrichman09,KawaguchiLahiriRebelo10,DwyerElbaumPerson08,EnglerRamos11}.

The problem of program differencing is fundamental~\cite{Hoare69} and early work mainly focused on computing syntactical difference~\cite{HuntMcIlroy75}. These solutions are an important stepping stone and we used syntactical diff as a means to achieve interleaving of programs in out correlating program for better analysis results. Another possibility for creating this program is to rely on the editing sequence that creates the new version from the original program~\cite{Horwitz90}.

We rely on classic methods of abstract interpretation~\cite{CousotCousot77} for presenting an over approximating solution for semantic differencing and equivalence. To achieve this we devised a static analysis over a correlating program. The idea of a correlating program is similar to that of self-composition~\cite{AikenTerauchi05} except that we compose two different programs in a interleaving designed to maintain a close correlation between them. The use of a correlating construct for differencing is novel as previous methods mainly use sequential composition~\cite{GodlinStrichman09,DwyerElbaumPerson08,EnglerRamos11}, disregarding possible program correlation.

We base our analysis on numerical abstractions~\cite{CousotHalbwachs78,Mine2006} that allow us to reason about variables of different programs. The abstraction is further refined in a way similar to trace partitioning~\cite{MauborgneRival07} with an equivalence-based partitioning criteria.

Jackson and Ladd~\cite{JacksonLadd94} proposed a tool for computing data dependencies between input and output variables and comparing these dependencies along versions of a program for discovering difference. This method may falsely report difference as semantic difference may occur even if data dependencies have not changed. Furthermore, data dependencies offer little insight as to the meaning of difference i.e. input and output values. Nevertheless, this was an important first step in employing program analysis as a means for semantic differencing.

Several works on the problem of equivalence of combinatorial circuits~\cite{KuehlmannKrohm97,BraytonChatterjeeMishchenkoEen06,ClarkeKroening03} made important contributions in establishing the problem of equivalence as feasible, producing practical solutions for hardware verification.

Symbolic execution based methods~\cite{DwyerElbaumPerson08,EnglerRamos11} offer practical equivalence verification techniques for loop and recursion free programs with small state space. These works complement each other in regards to reporting difference as one ~\cite{DwyerElbaumPerson08} presents an over approximating description of difference they call differential summaries and the other~\cite{EnglerRamos11} presents an under approximating description including concrete inputs for test cases demonstrating difference in behavior. An interesting question is how could these methods be combined iteratively to achieve better precision. Also, this work can be used to complement our work in cases where equivalence could not be proven and the description of difference can be leveraged for the extraction of concrete input that leads to offending states.

Bounded model checking based work~\cite{GodlinStrichman09} presents the notion of partial equivalence which allows checking for equivalence under specific conditions, supplied by the user but are bound by loops. They employ a technique based on theorem provers for proving an equivalence formula which embeds program logic (in SSA form) alongside the requirement for input and output equivalence and user provided constraints.

\cite{AmitRinetzkyRepsSagivYahav07} introduced a correlating heap semantics for verifying linearizability of concurrent programs. In their work, a correlating heap semantics is used to establish correspondence between a concurrent program and a sequential version of the program at specific linearization points.

\cite{BruynoogheJanssensVerdoolaege2009} presented an equivalence checking method for statically affine programs where the control flow is bound and determined at compile time. This approach cannot be applied to dynamic flow programs, specifically programs with an unbound loop counter.

In previous work regarding translation validation~\cite{PnueliSiegelSingerman98,Necula00,HuGoldbergFangPnueliZuck02}, in order to establish equivalence for a (looping) code fragment being translated or optimized by a compiler, a simulation relation between the basic blocks of the translated code is found. This method is limited in the context of semantic differencing as, for instance, a simulation relation for examples such as \figref{LoopExample} cannot be automatically established (it needs to be crafted manually as this is not one of the classic transformations). However, the correlating program method we propose is generic enough to establish equivalence for many cases, without requiring special tailoring.
