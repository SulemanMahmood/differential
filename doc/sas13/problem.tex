\section{Problem Definition}\label{Sec:ProblemDef}
To address the questions raised by our motivating examples we define the
goals of our work as such: Given a Program $P$ and a Patch $X$ we wish to:
\begin{enumerate}
\item Compute all program states $\semp{P} \setminus \semp{P\oplus X}$ that occurred in $P$ but do not
    exist in the patched program $P\oplus X$
\item Compute input that lead to the program states $S$.
\end{enumerate}
Where
\begin{itemize}
\item $\semp{\cdot}$ denotes all reachable concrete states in program $\cdot$
\item $P\oplus X$ denotes the patched program achieved by removing and
    adding lines of code according to $X$
\end{itemize}

%----------------State space unbounded, do over-approximation--------
Unfortunately, the concrete state space may be unbounded (e.g. integer
variables) making computation of said states not feasible. A proposed
solution would be to compute an \emph{over-approximation} of the program
states, while losing precision, such that it has an abstract bounded
representation but is still precise enough to extract the data we need. To
achieve this we can compute the abstract program states denoted by
$\asemp{P}\setminus \asemp{P\oplus X}$ where $\asemp{\cdot}$ denotes all
abstract states in $\cdot$ and is an over-approximation of $\semp{\cdot}$.
