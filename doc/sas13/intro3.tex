\section{Introduction} \seclabel{Intro}

%% what are we trying to say?
% 1. computing semantic diff is important
% 2. computing semantic diff is hard
% 3. existing approaches for computing semantic diff suck
% 4. our approach is great
% 5. technically, we use the following ideas:
%    - correlating program
%    - correlating abstract domains

% TODO:
% - we should have a clear problem definition somewhere
% - what is so special about a patched program?

Understanding the semantic difference between two versions of a program is invaluable in the process of software development. A developer applying a patch is often interested in answering questions like:
\begin{inparaenum}[(i)]
\item did the patch add/remove the desired functionality?
\item does the patch introduce other, \emph{unexpected}, behaviors?
\item which regression tests should be run?
\end{inparaenum}
Answering these questions manually is difficult and time consuming.

Semantic differencing has received much attention in classical work (e.g.,~\cite{Horwitz90,Horwitz89,Hoare69}) and has recently seen growing interest for various applications ranging from testing concurrent programs~\cite{ChakiGurfinkelStrichman12}, understanding software upgrades~\cite{JinOrsoXie10}, to automatic generation of security exploits~\cite{BrumleyPoosankamSongZheng08}.

\para{Problem Definition}
We define the problem of \emph{semantic differencing} as follows: Given a pair of programs $(P,P')$ that agree on the number and type of input and output variables, for every execution $\pi$ of $P$ that originates from an input $i$ and a corresponding execution $\pi'$ of $P'$ that originates from the \emph{same input $i$} our goal is:
\begin{inparaenum}[(i)]
\item Check whether $\pi$ and $\pi'$ have the same output i.e. are output-equivalent, and 
\item In case of difference in output variables, provide a description of the difference.
\end{inparaenum}

\para{Existing Techniques}
Existing techniques mostly offer solutions based on  under approximation, the most prominent of which is regression testing which provides limited assurance of behavior equivalence while consuming significant time and compute resources. \COMMENT{Kawaguchi et al.~\cite{KawaguchiLahiriRebelo10} define the notion of conditional equivalence but cannot compute differences in loops.}
Other approaches for computing semantics differences~\cite{DwyerElbaumPerson08,EnglerRamos11} rely on symbolic execution techniques, may miss differences, and are generally unable to prove equivalence. Previous work for equivalence checking~\cite{GodlinStrichman09} rely on unsound bounded model checking techniques to prove (input-output) equivalence of two closely related numerical programs, under certain conditions (see \secref{Related} for more details).

\para{Our Approach}
We present an approach based on abstract interpretation~\cite{CousotCousot77} for producing a \emph{sound} representation of changed program behaviors and proving equivalence between a program and a patched version of the program. Our method focuses on abstracting relationships between variables in both versions allowing us to achieve a precise description of the difference and prove equivalence. Our solution is sound in the sense that it computes an over approximation of the difference between the two versions, therefore guaranteeing equivalence when no difference is found.

We focus on output equivalence in the final state. This is sufficient as mid-execution output can be modeled as added variables in the final state. This limitation also means that we assume all program executions to be finite (i.e. equivalence/difference holds if indeed both executions terminate). Note that the definition limits program difference to the final state which alleviates the need for matching the different stages of $(P,P')$. Finding equivalence/difference in earlier stages of the program requires program matching (we first need to find a suitable location in both programs for checking for equivalence, otherwise it has no meaning). The problem of program matching is orthogonal and can be addressed via various techniques ranging in complexity and precision - from syntactic diff~\cite{HuntMcIlroy75} to execution indexing~\cite{Xin:2008} and others. In this work we employ a simple matching strategy to achieve better precision as described in \secref{Correlating}. We found this technique to be sufficient for our experiments.

To answer the question of semantic differencing for infinite-state programs, we employ abstract interpretation. Though the notion of difference is well defined in the concrete case, defining and soundly computing it under abstraction is challenging:
\begin{itemize}
\item Differencing requires correlation of \emph{different program executions}. The abstraction must be able to capture and compare only the input-equivalent executions, and avoid comparing ones that are not input-equivalent.
\item Equivalence of abstract output values does not entail concrete value equivalence.
\end{itemize}

To address these challenges, we introduce two new concepts:
\begin{inparaenum}[(i)]
\item \emph{correlating program} - a single program $P \correlate P'$ that captures the behaviors of both $P$ and $P'$ in a way that facilitates abstract interpretation;
\item \emph{correlating abstract domain} - a domain for tracking relationships between variables in $P$ and variables in $P'$ using $P \correlate P'$.
\end{inparaenum}

\para{Correlating Program}
We create a single program which captures the behavior of both the original program and its patched version. A \emph{correlating program} $P \correlate P'$ contains both programs flow and data, however program flow is arranged so to reflect a (simple) matching between the stages of the two programs. This matching is key for precision as otherwise we will not be able to maintain equivalence throughout the entire run of the program, particularly in the face of loops.

\para{Correlating Abstraction}
Abstracting relationships allows us to maintain focus on differences while over-approximating (whenever necessary for scalability) equivalent behaviors. We abstract variables of both programs together, starting off by assuming equality over all matched variables (variable matching is discussed in \secref{ConcreteSem}). Thus we can
reflect relationships without necessarily knowing the actual value of
variables. We focus on numerical programs and use numerical domains such as Octagon~\cite{Mine2006} and Polyhedra~\cite{CousotHalbwachs78} to capture the relationship between variables. Our current implementation does not track pointer equivalences, but such equivalences can be tracked by a using a correlating shape analysis domain~\cite{AmitRinetzkyRepsSagivYahav07}. To maintain equivalence as much as possible, our domain was designed to represent non-convex information (e.g. so we will not immediately lose equivalence taking a condition of the form $x \neq 0$ into account). We use a powerset domain of convex sub-states. Our domain uses a partitioning strategy that abstracts together states that have the same set of equivalent variables, thus avoiding exponential blowup (as explained in \secref{AbstractSem}). This strategy helps us preserve equivalence even across widening. Therefore our domain may over-approximate numerical information as long as equivalence between correlated variables is preserved.

\subsection{Main Contributions}
The main contributions of this paper are as follows:
\begin{itemize}
\item We present a novel approach for computing abstract semantic difference between a program $P$ and a patched version of the program $P'$. We focus on numerical programs where the values of variables have no a-priori bounds.
\item We reduce the problem of analyzing the two programs $P,P'$ to the problem of analyzing a single \emph{correlating program} $P \correlate P'$ that captures the behavior of $P$ and $P'$.
\item We present a \emph{correlating abstract domain} that captures an over-approximation of the difference between P and P' by tracking relationships between variables in $P \correlate P'$. The domain applies a partitioning strategy for scaling the analysis while maintaining precision in equivalence.
\item We have implemented our approach in a tool based on the \sname{LLVM} compiler infrastructure and the \sname{APRON} numerical abstract domain library, and applied it to several real-world programs. Our evaluation shows that the tool often manages to establish equivalence, reports useful approximation of semantic differences when differences exists, and reports only a few false differences.
\end{itemize}
