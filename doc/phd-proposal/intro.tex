\section{Introduction} \seclabel{Intro}

We present a novel technique for identifying and describing semantic change in programs while relying on abstract interpretation and program analysis methods~\cite{CousotCousot77}. We define the problem of \emph{semantics differencing} as identifying observable difference in behavior for executions originating from \emph{the same input}. The notion of observable difference can be trivially defined as difference in output values in the final state~\cite{DwyerElbaumPerson08,GodlinStrichman09,EnglerRamos11,HawblitzelKawaguchiLahiriRebelo12}, but our research extends this notions to detect other important behavioral differences such as array access patterns, assertion failures, etc.

%Understanding the semantic difference between two versions of a program is invaluable in the process of software development. A developer making changes to a program is often interested in answering questions like:
%\begin{inparaenum}[(i)]
%\item did the patch add/remove the desired functionality?
%\item does the patch introduce other, \emph{unexpected}, behaviors?
%\item which regression tests should be run?
%\end{inparaenum}
%Answering these questions manually is difficult and time consuming.

\para{Motivation}
Differential analysis has received attention in classical work (e.g.,~\cite{Horwitz90,Horwitz89,JacksonLadd94}) and recently been the subject of research in program analysis~\cite{DwyerElbaumPerson08,GodlinStrichman09,EnglerRamos11,HawblitzelKawaguchiLahiriRebelo12}. Hoare recently suggested~\cite{HoareLahiriVaswani10} several applications where static analysis can be easily adopted as an effective solution for tasks such as equivalence checking, semantic diffing, differential contract checking, patch debugging, etc. Specifying semantic difference between program versions has seen growing interest for various applications ranging from testing of concurrent programs~\cite{ChakiGurfinkelStrichman12}, understanding software upgrades~\cite{JinOrsoXie10}, to automatic generation of security exploits~\cite{BrumleyPoosankamSongZheng08}.

\para{Problem Definition}
We define the problem of \emph{semantics differencing} as follows: Given a pair of programs $(P,P')$ that agree on the number and type of inputs (i.e. have the same prototype), for every execution $\pi$ of $P$ that originate from an input $i$ and a corresponding execution $\pi'$ of $P'$ that originates from the \emph{same input $i$} our goal is:
\begin{itemize}
\item Check whether $\pi$ and $\pi'$ agree on output i.e., are output-equivalent.
\item In case of difference in behavior, provide a description of difference.
\end{itemize}
We intentionally define the notion of input and output equivalence loosely at this point, and we discuss several realizations of these in later sections. Take notice that this definition alleviates the need to provide detailed description of \emph{equivalent behaviors}, allowing for a more scalable solution.

To answer the question of semantic differencing for infinite-state programs, we employ abstract interpretation. Though the notion of difference is well defined in the concrete case, defining and soundly computing it under abstraction is challenging as:
\begin{itemize}
\item Differencing requires correlation of \emph{different program executions} meaning the abstraction must be able to capture and compare only the input-equivalent executions, and avoid comparing ones that are not input-equivalent.
\item Equivalence of abstract output values does not entail concrete value equivalence.
\end{itemize}

\para{Applications}
We propose the following applications of differential program analysis:
\begin{itemize}
\item (Parital) Equivalence checking - proving that two versions of a program are (partially) equivalent.
\item Semantic diff - describing how output changes between two programs and for which inputs.
\item Differential contract checking - describing how specification changes between two programs.
\item Regression testing - automatically pruning and synthesizing regression tests.
\item Patch debugging - help debug program patches by explaining difference and directing towards relevant code locations.
\item Synthesis of attacks from patches - automatically generate an attack from a patch.
\end{itemize}

\para{Our Approach}
In contrast to existing recent techniques for semantic differencing, that rely on variants of (bounded) symbolic execution and SMT solving~\cite{DwyerElbaumPerson08,GodlinStrichman09,EnglerRamos11,HawblitzelKawaguchiLahiriRebelo12}, our technique employs abstract interpretation for identifying difference. This means that our approach can provide a sound characterization of program differences. Further, our approach has the potential to scale better existing techniques by using abstractions of varying precision (and cost). Using abstract interpretation for differential analysis means reasoning over two programs. One of the challenges in applying abstract interpretation is the fact that equality of two abstract program states does not entail concrete equality. Furthermore, defining a useful notion of equality is a challenge on its own right.
We address these challenges by presenting:
\begin{itemize}
\item a method for abstract interpretation of a pair of programs $(P,P')$ for \emph{sound} semantic equivalence and differencing by abstracting direct relationships between $(P,P')$ variables in a partially disjunctive domain. We describe a partitioning technique for state reduction and scaling. We define a widening operator for abstracting unbounded paths in our domain.
\item a new technique for syntactically interleaving a pair of programs $(P,P')$ for the creation of a \emph{correlating program} $P \bowtie P'$ which contains the semantics of both programs. We propose an analysis over the program for characterizing program equivalence and difference, based on the aforementioned abstraction, given the properties of the correlating program which aligns $(P,P')$ executions.
\end{itemize}

We have implemented our approach in a tool based on the \sname{LLVM} compiler infrastructure and the \sname{APRON} numerical abstract domain library, and evaluated it using select patches from open-source software including GNU core utilities, Mozilla Firefox, and the Linux Kernel. Our evaluation shows that the tool often manages to establish equivalence, reports useful approximation of semantic differences when differences exists, and reports only a few false differences.

We plan further research for refining and adjusting our technique to achieve better results on a wider range of programs by extending our analysis to be inter-procedural, using several abstract domains to capture differences in more complex data structures (pointers, heaps) and differencing concurrent programs.

We do not limit ourselves purely to abstract interpretation techniques and one future direction of our work will include applying existing dynamic analysis and symbolic execution techniques on correlated programs. The interleaved structure offered by the correlating program holds great potential as it alleviates the need to "delay" differencing until both programs have been analyzed completely (this will be further explained in \secref{Future}). Another major research direction will different compositions of the correlating program that will allow for better differencing. Specifically, an equivalence-guided correlation refinement technique can be used i.e. the way the programs are interleaved will be directed by the analysis according to equivalence criteria.

As our results so far have limited use as they basically offer an abstraction of program difference at a certain program location, we also plan to produce techniques for using our results towards practical applications such as regression test generation, patch installation debugging and synthesis of attacks from a patch.

